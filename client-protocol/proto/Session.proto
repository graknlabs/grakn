syntax = "proto3";

option java_package = "ai.grakn.rpc.proto";
option java_outer_classname = "SessionProto";

import "Concept.proto";
import "Iterator.proto";

service Session {
    // Represents a full transaction. The stream of `TxRequest`s must begin with a `Open` message.
    // When the call is completed, the transaction will always be closed, with or without a `Commit` message.
    rpc transaction (stream TxRequest) returns (stream TxResponse);
}

message TxRequest {
    oneof request {
        Open.Req open = 1;
        Commit.Req commit = 2;
        Query.Req query = 3;
        Next next = 4;
        Stop stop = 5;
        GetConcept.Req getConcept = 6;
        GetAttributes.Req getAttributes = 7;
        GetSchemaConcept.Req getSchemaConcept = 8;
        PutEntityType.Req putEntityType = 9;
        PutAttributeType.Req putAttributeType = 10;
        string putRelationshipType = 11; // returns Concept
        string putRole = 12; // returns Concept
        Rule putRule = 13; // returns Concept
        RunConceptMethod runConceptMethod = 14; // returns ConceptResponse
    }
}

message TxResponse {
    oneof response {
        Open.Res open = 10;
        Commit.Res commit = 11;
        Query.Res query = 12;
        GetConcept.Res getConcept = 13;
        GetAttributes.Res getAttributes = 14;
        GetSchemaConcept.Res getSchemaConcept = 15;
        PutEntityType.Res putEntityType = 16;
        PutAttributeType.Res putAttributeType = 17;
        Answer answer = 1;
        Done done = 2;
        ConceptResponse conceptResponse = 3;
        IteratorId iteratorId = 4;
        Concept concept = 5;
        RolePlayer rolePlayer = 7;
        bool noResult = 8;
    }
}

enum TxType {
    Read = 0;
    Write = 1;
    Batch = 2;
}

message Done {} // Indicates that a request is completedk
message Null {} // Indicates that a request does not yield any result

message Open { // Opening a transaction on a keyspace, which must be the first message sent
    message Req {
        string keyspace = 1;
        TxType txType = 2;
        /* Fields ignored in the open-source version. */
        string username = 3;
        string password = 4;
    }
    message Res {}
}

message Commit { // Command to commit a transaction
    message Req {}
    message Res {}
}

message Query { // Graql query to be executed on the database
    message Req {
        string query = 1; // query string
        bool infer = 2; // If this is not present, leave at server default.
    }
    message Res {
        oneof res {
            IteratorId iteratorId = 1;
            Null null = 2;
        }
    }
}

message GetConcept {
    message Req {
        string id = 1;
    }
    message Res {
        oneof res {
            Concept concept = 1;
            Null null = 2;
        }
    }
}

message GetSchemaConcept {
    message Req {
        string label = 1;
    }
    message Res {
        oneof res {
            Concept concept = 1;
            Null null = 2;
        }
    }
}

message GetAttributes {
    message Req {
        AttributeValue value = 1;
    }
    message Res {
        IteratorId iteratorId = 1;
    }
}

message PutEntityType {
    message Req {
        string label = 1;
    }
    message Res {
        Concept concept = 1;
    }
}

message PutAttributeType {
    message Req {
        string label = 1;
        DataType dataType = 2;
    }
    message Res {
        Concept concept = 1;
    }
}
message Answer {
    oneof answer {
        QueryAnswer queryAnswer = 1;
        ComputeAnswer computeAnswer = 2;
        string otherResult = 3;
        // otherResult is used to represent `aggregate` query results.
        // Due to the many different output formats, we are just returning them as JSON for now.
    }
}

message QueryAnswer {
    map<string, Concept> queryAnswer = 1;
}

message ComputeAnswer {
    oneof computeAnswer {
        string number = 1; // number is stored as string  to accomodate numerics of any type (int, long, float, double)
        Paths paths = 2;
        Centrality centrality = 3;
        Clusters clusters = 4;
        ClusterSizes clusterSizes = 5;
    }
}

message Paths {
    repeated ConceptIds paths = 1;
}

message Centrality {
    map<int64, ConceptIds> centrality = 1;
}

message Clusters {
    repeated ConceptIds clusters = 1;
}

message ClusterSizes {
    repeated int64 clusterSizes = 1;
}

message RunConceptMethod { // Calling a method on a concept
    string id = 1;
    ConceptMethod method = 2;
}

message Rule {
    string label = 1;
    string when = 2;
    string then = 3;
}