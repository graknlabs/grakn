syntax = "proto3";

option java_package = "ai.grakn.rpc.proto";
option java_outer_classname = "TransactionProto";

import "concept.proto";
import "iterator.proto";

service Transaction {
    // Represents a full transaction. The stream of `TxRequest`s must begin with a `Open` message.
    // When the call is completed, the transaction will always be closed, with or without a `Commit` message.
    rpc Tx (stream TxRequest) returns (stream TxResponse);
}

message TxRequest {
    oneof request {
        Open open = 1; // returns Done
        Commit commit = 2; // returns Done
        Query query = 3; // returns QueryResult, Done, or IteratorId of QueryResult
        Next next = 4; // returns QueryResult or Done
        Stop stop = 5; // returns Done
        string getConcept = 7; // returns Concept or noResult
        string getSchemaConcept = 8; // returns Concept or noResult
        string putEntityType = 10; // returns Concept
        string putRelationshipType = 11; // returns Concept
        string putRole = 13; // returns Concept
        Rule putRule = 14; // returns Concept
        AttributeValue getAttributesByValue = 9; // returns IteratorId of Concept
        AttributeType putAttributeType = 12; // returns Concept
        RunConceptMethod runConceptMethod = 6; // returns ConceptResponse
    }
}

message TxResponse {
    oneof response {
        Answer answer = 1;
        Done done = 2;
        ConceptResponse conceptResponse = 3;
        IteratorId iteratorId = 4;
        Concept concept = 5;
        RolePlayer rolePlayer = 7;
        bool noResult = 8;
    }
}

enum TxType {
    Read = 0;
    Write = 1;
    Batch = 2;
}

message Open { // Opening a transaction on a keyspace, which must be the first message sent
    string keyspace = 1;
    TxType txType = 2;
    /* Fields ignored in the open-source version. */
    string username = 3;
    string password = 4;
}

message Commit {} // Command to commit a transaction

message Done {} // Tells the client we have completed their command.

message Query { // Graql query to be executed on the database
    string query = 1; // query string
    bool infer = 2; // If this is not present, leave at server default.
}

message Answer {
    oneof answer {
        QueryAnswer queryAnswer = 1;
        ComputeAnswer computeAnswer = 2;
        string otherResult = 3;
        // otherResult is used to represent `aggregate` query results.
        // Due to the many different output formats, we are just returning them as JSON for now.
    }
}

message QueryAnswer {
    map<string, Concept> queryAnswer = 1;
}

message ComputeAnswer {
    oneof computeAnswer {
        string number = 1; // number is stored as string  to accomodate numerics of any type (int, long, float, double)
        Paths paths = 2;
        Centrality centrality = 3;
        Clusters clusters = 4;
        ClusterSizes clusterSizes = 5;
    }
}

message Paths {
    repeated ConceptIds paths = 1;
}

message Centrality {
    map<int64, ConceptIds> centrality = 1;
}

message Clusters {
    repeated ConceptIds clusters = 1;
}

message ClusterSizes {
    repeated int64 clusterSizes = 1;
}

message RunConceptMethod { // Calling a method on a concept
    string id = 1;
    ConceptMethod method = 2;
}

message AttributeType {
    string label = 1;
    DataType dataType = 2;
}

message Rule {
    string label = 1;
    string when = 2;
    string then = 3;
}