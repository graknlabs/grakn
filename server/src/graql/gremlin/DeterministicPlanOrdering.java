package grakn.core.graql.gremlin;

import grakn.core.graql.gremlin.spanningtree.graph.Node;
import grakn.core.graql.gremlin.spanningtree.graph.SparseWeightedGraph;
import grakn.core.graql.reasoner.utils.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class DeterministicPlanOrdering {
    protected static final Logger LOG = LoggerFactory.getLogger(DeterministicPlanOrdering.class);

    /**
     * Iterating over every connected node in the QP graph, we combine the neighbor's hashes (in a sorted order)
     * with the node's local hashcode to get a deterministic hash code without depending on the autogenerated variable
     * names
     *
     * This "global" hash code could be improved by implementing a full network broadcast that combines
     * all nodes into the graph into each node, taking into account the number of hops taken across the network
     * to differentiate graph structure, which break ties that currently occur when the 1-hop neighbor is identical
     * across two nodes in the QP graph
     */
    public static void injectDeterministicNodeHashes(SparseWeightedGraph weightedGraph, int depth) {
        // order the nodes so the iterations are deterministic
        List<Node> nodes = weightedGraph.getNodes().stream().sorted(Comparator.comparing(Node::localHashCode)).collect(Collectors.toList());
        Map<Node, MessagePassingNode> mpNodes = new HashMap<>();
        nodes.forEach(node -> mpNodes.put(node, new MessagePassingNode(node)));
        for (Node node : nodes) {
            Set<MessagePassingNode> neighborMPNodes = weightedGraph.getIncomingEdges(node)
                    .stream().map(weightedEdge -> weightedEdge.val.source)
                    .map(mpNodes::get)
                    .collect(Collectors.toSet());
            mpNodes.get(node).setNeighbors(neighborMPNodes);
        }

        // pregel-like super steps, in each we:
        // 1. filtering received messages on each node and prepare to send
        // 2. Move prepared messages to neighboring receive queues
        // so the end result is that in iteration 1, all 0-hop exchanges have happened and been recorded
        // iteration 2, all 1-hop exchanges have been recorded... etc.
        //
        // the two-step process (vs one queue per node) means we can properly limit maximum transmit depth rather than having one lucky message
        // ride a wave all the way through the graph while others only get a short distance
        int totalMessages = 0;
        int i = 0;
        boolean fixedPointReached = false;
        while (!fixedPointReached && i != depth) {
            for (MessagePassingNode mpNode : mpNodes.values()) {
                mpNode.processReceivedMessages();
            }

            int messagesThisIteration = 0;
            for (MessagePassingNode mpNode : mpNodes.values()) {
                messagesThisIteration += mpNode.sendMessages();
            }

            totalMessages += messagesThisIteration;
            fixedPointReached = messagesThisIteration == 0;
            i++;
        }

        LOG.trace("Total messages passed in [" + i + "] iterations: " + totalMessages);
        System.out.println("Total messages passed in [" + i + "] iterations: " + totalMessages);

        for (MessagePassingNode mpNode : mpNodes.values()) {
            Map<Integer, List<Node>> distances = mpNode.distancesToNodes();
            List<Object> toHash = new ArrayList<>();
            for (Integer distance : distances.keySet().stream().sorted().collect(Collectors.toList())) {
                toHash.add(distance);
                List<Node> nodesAtDistance = distances.get(distance);
                nodesAtDistance.stream()
                    .map(Node::localHashCode)
                    .sorted()
                    .forEach(toHash::add);
            }

            Node node = mpNode.node;
            node.setGlobalHash(toHash.hashCode());
        }

    }

    private static class MessagePassingNode {

        Node node;
        Set<MessagePassingNode> neighbors;

        Map<Node, Integer> nodeDistances = new HashMap<>();
        List<Pair<Node, Integer>> receiveQueue = new ArrayList<>();
        List<Pair<Node, Integer>> sendQueue = new ArrayList<>();

        MessagePassingNode(Node thisNode) {
            this.node = thisNode;

            // initialise the receive queue with this node's distance so we automatically retransmit the message
            // without special logic
            receiveQueue.add(new Pair<>(thisNode, 0));
        }

        void setNeighbors(Set<MessagePassingNode> neighbors) {
            this.neighbors = neighbors;
        }

        int sendMessages() {
            int messagesSent = 0;
            // consume receive queue
            for (Pair<Node, Integer> message : sendQueue) {
                for (MessagePassingNode neighbor : neighbors) {
                    neighbor.receiveQueue.add(message);
                    messagesSent++;
                }
            }
            sendQueue.clear();
            return messagesSent;
        }

        void processReceivedMessages() {
            for (Pair<Node, Integer> receivedMessage : receiveQueue) {
                Node sourceNode = receivedMessage.getKey();
                Integer sourceDistance = receivedMessage.getValue();
                if (nodeDistances.containsKey(sourceNode)) {
                    // we have already seen it, so we can ignore
                    assert nodeDistances.get(sourceNode) <= sourceDistance;
                } else {
                    nodeDistances.put(sourceNode, sourceDistance);
                    sendQueue.add(new Pair<>(sourceNode, sourceDistance + 1));
                }
            }
            receiveQueue.clear();
        }

        Map<Integer, List<Node>> distancesToNodes() {
            // invert the node -- distance map and return
            Map<Integer, List<Node>> mapping = new HashMap<>();
            for (Map.Entry<Node, Integer> nodeDistanceEntry: nodeDistances.entrySet()) {
                mapping.putIfAbsent(nodeDistanceEntry.getValue(), new ArrayList<>());
                mapping.get(nodeDistanceEntry.getValue()).add(nodeDistanceEntry.getKey());
            }

            return mapping;
        }
    }


}
