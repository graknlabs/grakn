/*
 * Grakn - A Distributed Semantic Database
 * Copyright (C) 2016  Grakn Labs Limited
 *
 * Grakn is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Grakn is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Grakn. If not, see <http://www.gnu.org/licenses/gpl.txt>.
 *
 */

package ai.grakn.generator;

import ai.grakn.Grakn;
import ai.grakn.GraknGraph;
import ai.grakn.GraknGraphFactory;
import ai.grakn.concept.Concept;
import ai.grakn.concept.EntityType;
import ai.grakn.concept.Instance;
import ai.grakn.concept.Relation;
import ai.grakn.concept.RelationType;
import ai.grakn.concept.Resource;
import ai.grakn.concept.ResourceType;
import ai.grakn.concept.RoleType;
import ai.grakn.concept.Rule;
import ai.grakn.concept.RuleType;
import ai.grakn.concept.Type;
import ai.grakn.concept.TypeName;
import ai.grakn.exception.GraphRuntimeException;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.pholser.junit.quickcheck.generator.GeneratorConfiguration;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.util.Collection;
import java.util.List;
import java.util.function.Function;

import static ai.grakn.graql.Graql.var;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * Generator to create random {@link GraknGraph}s.
 */
@SuppressWarnings("unchecked") // We're performing random operations. Generics will not constrain us!
public class GraknGraphs extends AbstractGenerator<GraknGraph> {

    private static GraknGraph lastGeneratedGraph;

    private GraknGraph graph;
    private Boolean open = null;

    public GraknGraphs() {
        super(GraknGraph.class);
    }

    public static GraknGraph lastGeneratedGraph() {
        if (lastGeneratedGraph == null) {
            throw new IllegalStateException("No graph to generate from");
        }
        return lastGeneratedGraph;
    }

    /**
     * Mutate the graph being generated by calling a random method on it.
     */
    private void mutateOnce() {
        boolean succesfulMutation = false;

        while (!succesfulMutation) {
            succesfulMutation = true;
            try {
                random.choose(mutators).run();
            } catch (UnsupportedOperationException | GraphRuntimeException | GraphGeneratorException e) {
                // We only catch acceptable exceptions for the graph API to throw
                succesfulMutation = false;
            }
        }
    }

    @Override
    public GraknGraph generate() {
        // TODO: Generate more keyspaces
        // We don't do this now because creating lots of keyspaces seems to slow the system graph
        String keyspace = gen().make(MetasyntacticStrings.class).generate(random, status);
        GraknGraphFactory factory = Grakn.factory(Grakn.IN_MEMORY, keyspace);

        // Clear graph before retrieving
        graph = factory.getGraph();
        graph.clear();
        graph = factory.getGraph();

        for (int i = 0; i < status.size(); i++) {
            mutateOnce();
        }

        // Close graphs randomly, unless parameter is set
        boolean shouldOpen = open != null ? open : random.nextBoolean();

        if (!shouldOpen) graph.close();

        lastGeneratedGraph = graph;
        return graph;
    }

    public void configure(Open open) {
        setOpen(open.value());
    }

    public GraknGraphs setOpen(boolean open) {
        this.open = open;
        return this;
    }

    // A list of methods that will mutate the graph in some random way when called
    private final ImmutableList<Runnable> mutators = ImmutableList.of(
            () -> graph.putEntityType(typeName()),
            () -> graph.putResourceType(typeName(), gen(ResourceType.DataType.class)),
            () -> graph.putResourceTypeUnique(typeName(), gen(ResourceType.DataType.class)),
            () -> graph.putRoleType(typeName()),
            () -> graph.putRelationType(typeName()),
            () -> graph.showImplicitConcepts(gen(Boolean.class)),
            () -> type().playsRole(roleType()),
            () -> type().hasResource(resourceType()),
            () -> type().key(resourceType()),
            () -> type().setAbstract(true),
            () -> entityType().superType(entityType()),
            () -> entityType().addEntity(),
            () -> roleType().superType(roleType()),
            () -> relationType().superType(relationType()),
            () -> relationType().addRelation(),
            () -> relationType().hasRole(roleType()),
            () -> resourceType().superType(resourceType()),
            () -> resourceType().putResource(gen().make(ResourceValues.class).generate(random, status)),
            // () -> resourceType().setRegex(gen(String.class)), // TODO: Enable this when doesn't throw a NPE
            () -> ruleType().superType(ruleType()),
            () -> ruleType().addRule(var("x"), var("x")), // TODO: generate more complicated rules
            () -> instance().hasResource(resource()),
            () -> relation().scope(instance()),
            () -> relation().putRolePlayer(roleType(), instance())
    );

    private TypeName typeName() {
        return gen().make(TypeNames.class, gen().make(MetasyntacticStrings.class)).generate(random, status);
    }

    private Type type() {
        return random.choose(graph.admin().getMetaConcept().subTypes());
    }

    private EntityType entityType() {
        return random.choose(graph.admin().getMetaEntityType().subTypes());
    }

    private RoleType roleType() {
        return random.choose(graph.admin().getMetaRoleType().subTypes());
    }

    private ResourceType resourceType() {
        return random.choose((Collection<ResourceType>) graph.admin().getMetaResourceType().subTypes());
    }

    private RelationType relationType() {
        return random.choose(graph.admin().getMetaRelationType().subTypes());
    }

    private RuleType ruleType() {
        return random.choose(graph.admin().getMetaRuleType().subTypes());
    }

    private Instance instance() {
        return chooseOrThrow(graph.admin().getMetaConcept().instances());
    }

    private Relation relation() {
        return chooseOrThrow(graph.admin().getMetaRelationType().instances());
    }

    private Resource resource() {
        return chooseOrThrow((Collection<Resource>) graph.admin().getMetaResourceType().instances());
    }

    private Rule rule() {
        return chooseOrThrow(graph.admin().getMetaRuleType().instances());
    }

    private <T> T chooseOrThrow(Collection<? extends T> collection) {
        if (collection.isEmpty()) {
            throw new GraphGeneratorException();
        } else {
            return random.choose(collection);
        }
    }

    public static List<Concept> allConceptsFrom(GraknGraph graph) {
        List<Concept> concepts = Lists.newArrayList(GraknGraphs.allTypesFrom(graph));
        concepts.addAll(allInstancesFrom(graph));
        return concepts;
    }

    public static Collection<? extends Type> allTypesFrom(GraknGraph graph) {
        return withImplicitConceptsVisible(graph, g -> g.admin().getMetaConcept().subTypes());
    }

    public static Collection<? extends Instance> allInstancesFrom(GraknGraph graph) {
        return withImplicitConceptsVisible(graph, g -> g.admin().getMetaConcept().instances());
    }

    public static <T> T withImplicitConceptsVisible(GraknGraph graph, Function<GraknGraph, T> function) {
        boolean implicitFlag = graph.implicitConceptsVisible();
        graph.showImplicitConcepts(true);
        T result = function.apply(graph);
        graph.showImplicitConcepts(implicitFlag);
        return result;
    }

    @Target({PARAMETER, FIELD, ANNOTATION_TYPE, TYPE_USE})
    @Retention(RUNTIME)
    @GeneratorConfiguration
    public @interface Open {
        boolean value() default true;
    }

    private class GraphGeneratorException extends RuntimeException {

    }
}
